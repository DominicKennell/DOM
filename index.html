<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DOM</title>
<style>
body {
    background: #1e1e1e;
    color: #fff;
    font-family: monospace;
    padding: 10px;
}
#controls { margin-bottom: 10px; }
button { padding: 5px 10px; margin-right: 5px; }
#resources {
    border: 1px solid #444;
    padding: 5px;
    margin-bottom: 10px;
}
.resource-bar {
    position: relative;
    background: #222;
    border: 1px solid #444;
    margin: 2px 0;
     width: 200px;
    height: 18px;
}
.resource-fill {
    position: absolute;
    height: 100%;
    background: #66ff66;
    width: 0%;
}
#simulation {
     border: 1px solid #444;
     padding: 10px;
    max-height: 60vh;
    overflow-y: scroll;
}
.agent {
    margin-bottom: 2px;
    padding: 2px 4px;
    border-radius: 3px;
    display: inline-block;
}
</style>
</head>
<body>
<h1>SIMULATION DOM</h1>
<div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
</div>
<div id="resources"></div>
<div id="simulation"></div>

<script>
// --- Shared AudioContext & New Global State for Hearing ---
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let recentSignals = []; // NEW: Logs all signals played in the current step

// --- Neural Network (Input Size updated to 14) ---
class NeuralNetwork {
    // INPUT SIZE IS NOW 14
    constructor(inputSize=14, hiddenSize=16, outputSize=5, lr=0.05){ 
        this.inputSize=inputSize; this.hiddenSize=hiddenSize; this.outputSize=outputSize; this.lr=lr;
        this.W1=Array.from({length:hiddenSize}, ()=>Array.from({length:inputSize}, ()=>Math.random()*0.2-0.1));
        this.b1=Array(hiddenSize).fill(0);
        this.W2=Array.from({length:outputSize}, ()=>Array.from({length:hiddenSize}, ()=>Math.random()*0.2-0.1));
        this.b2=Array(outputSize).fill(0);
    }
    tanh(x){ return Math.tanh(x); }
    dtanh(y){ return 1-y*y; }
    softmax(arr){ const max=Math.max(...arr); const exps=arr.map(v=>Math.exp(v-max)); const sum=exps.reduce((a,b)=>a+b,0); return exps.map(v=>v/sum); }
    forward(x){
        this.x=x.slice();
        this.z1=this.W1.map((row,i)=>row.reduce((sum,v,j)=>sum+v*x[j],0)+this.b1[i]);
        this.a1=this.z1.map(v=>this.tanh(v));
        this.z2=this.W2.map((row,i)=>row.reduce((sum,v,j)=>sum+v*this.a1[j],0)+this.b2[i]);
        this.a2=this.softmax(this.z2);
        return this.a2;
    }
    train(actionIdx,reward){
        const dZ2=this.a2.slice(); dZ2[actionIdx]-=1; for(let i=0;i<dZ2.length;i++) dZ2[i]*=reward;
        const dW2=this.W2.map((row,i)=>row.map((v,j)=>dZ2[i]*this.a1[j])); const db2=dZ2.slice();
        const da1=Array(this.hiddenSize).fill(0);
        for(let i=0;i<this.hiddenSize;i++) for(let j=0;j<this.outputSize;j++) da1[i]+=this.W2[j][i]*dZ2[j];
        const dz1=da1.map((v,i)=>v*(1-this.a1[i]**2));
        const dW1=this.W1.map((row,i)=>row.map((v,j)=>dz1[i]*this.x[j])); const db1=dz1.slice();
        for(let i=0;i<this.W2.length;i++){ for(let j=0;j<this.W2[0].length;j++) this.W2[i][j]-=this.lr*dW2[i][j]; this.b2[i]-=this.lr*db2[i]; }
        for(let i=0;i<this.W1.length;i++){ for(let j=0;j<this.W1[0].length;j++) this.W1[i][j]-=this.lr*dW1[i][j]; this.b1[i]-=this.lr*db1[i]; }
    }
}

// --- Environment ---
const environment = {
    food: 500, energy: 500, metal: 300,
    water: 400, fire: 200, air: 300, trees: 350
};

// --- Agent (Updated for Survival and Sensing) ---
class Agent{
    constructor(name,parent=null, generation=0){
        // Survival adjustments
        this.name=name; this.food=40; this.energy=40; this.metal=10; this.alive=true;
        this.strength=Math.floor(Math.random()*10)+1; this.cooperation=Math.random();
        this.lifetimeReward=0; this.children=[]; this.lastAction="None"; this.memory=[]; this.MAX_MEMORY=5; this.trust={};
        this.generation=generation;
        this.melodyTendency=parent ? Math.min(Math.max(parent.melodyTendency+(Math.random()-0.5)*0.2,0),1) : Math.random();
        this.rhythmComplexity=parent ? Math.min(Math.max(parent.rhythmComplexity+(Math.random()-0.5)*0.2,0),1) : Math.random();
        this.harmonyPreference=parent ? Math.min(Math.max(parent.harmonyPreference+(Math.random()-0.5)*0.2,0),1) : Math.random();
        if(parent){
            this.signalMap={};
            for(let action in parent.signalMap){
                this.signalMap[action]=parent.signalMap[action].map(f=>f+(Math.random()-0.5)*4);
            }
        } else {
            this.signalMap={gather:[400,500],trade:[500,600],fight:[700,800],social:[300,400],reproduce:[600,700]};
        }
        this.nn=new NeuralNetwork();
    }

    getState(){
        const avgReward=this.memory.length>0 ? this.memory.reduce((a,b)=>a+b[2],0)/this.memory.length :0;
        const avgTrust=Object.keys(this.trust).length>0 ? Object.values(this.trust).reduce((a,b)=>a+b,0)/Object.keys(this.trust).length :0;

        // --- NEW: Sensing Logic ---
        let totalMelody = 0;
        let totalRhythm = 0;
        const relevantSignals = recentSignals.filter(s => s.action !== this.lastAction); // Ignore own signal
        const numSignals = relevantSignals.length;

        if (numSignals > 0) {
            relevantSignals.forEach(s => {
                totalMelody += s.melody;
                totalRhythm += s.rhythm;
            });
        }
        const avgHeardMelody = numSignals > 0 ? (totalMelody / numSignals) : 0;
        const avgHeardRhythm = numSignals > 0 ? (totalRhythm / numSignals) : 0;
        // ---------------------------

        return [
            this.food/50,this.energy/50,this.metal/30,
            this.strength/10,this.cooperation,
            this.melodyTendency,this.rhythmComplexity,this.harmonyPreference,
            avgReward,avgTrust,this.memory.length/this.MAX_MEMORY,Math.random(),
            // NEW: 13th and 14th Input for Hearing
            avgHeardMelody,
            avgHeardRhythm 
        ];
    }

    chooseAction(){
        const state=this.getState();
        const probs=this.nn.forward(state);
        let sum=0; const r=Math.random();
        for(let i=0;i<probs.length;i++){ sum+=probs[i]; if(r<sum){ this.lastActionIdx=i; break; } }
        const actions=["gather","trade","fight","social","reproduce"];
        this.lastAction=actions[this.lastActionIdx]||"gather";
        return this.lastAction;
    }

    act(agents){
        if(!this.alive) return;
        this.chooseAction(); let reward=0;
        agents.forEach(a=>{this.trust[a.name]=this.trust[a.name]||0.5; a.trust[this.name]=a.trust[this.name]||0.5; });

        switch(this.lastAction){
            case "gather":
                const resKeys=Object.keys(environment);
                const res=resKeys[Math.floor(Math.random()*resKeys.length)];
                const gathered=Math.min(environment[res],Math.floor(Math.random()*5)+1);
                environment[res]-=gathered;
                if(res==="food") this.food+=gathered;
                else if(res==="energy") this.energy+=gathered;
                else if(res==="metal") this.metal+=gathered;
                reward+=gathered/2; 
                break;
            case "trade":
                const partners=agents.filter(a=>a!==this && a.alive && this.trust[a.name]>0.3);
                if(partners.length>0){
                    const partner=partners[Math.floor(Math.random()*partners.length)];
                    const tradeAmount=Math.min(this.metal,Math.floor(Math.random()*3)+1);
                    if(tradeAmount>0){ this.metal-=tradeAmount; partner.food+=tradeAmount; reward+=tradeAmount/3; }
                }
                break;
            case "fight":
                const targets=agents.filter(a=>a!==this && a.alive);
                if(targets.length>0){
                    const target=targets[Math.floor(Math.random()*targets.length)];
                    if(this.strength>target.strength){
                        const stolen=Math.min(target.food,Math.floor(Math.random()*3)+1);
                        target.food-=stolen; this.food+=stolen; reward+=stolen/3; this.trust[target.name]-=0.1;
                    } else { reward-=0.2; this.trust[target.name]+=0.05; }
                }
                break;
            case "social":
                this.food-=1; reward-=0.1; agents.forEach(a=>{ if(a!==this) this.trust[a.name]+=0.01; });
                break;
            case "reproduce":
                if(this.food>10 && this.energy>10){
                    this.food-=10; this.energy-=10;
                    const child=new Agent(this.name+"_child",this,this.generation+1);
                    this.children.push(child);
                    agents.push(child);
                    reward+=0.5;
                }
                break;
        }

        reward+=0.5; this.food-=0.5; this.energy-=0.5;
        if(this.food<=0 || this.energy<=0){ this.alive=false; reward-=2.0; }

        this.lifetimeReward+=reward;
        if(typeof this.lastActionIdx!=="undefined") this.nn.train(this.lastActionIdx,reward);
        
        // --- NEW: Broadcast Signal Data to Environment ---
        if (this.alive) {
            const signalData = {
                action: this.lastAction,
                melody: this.melodyTendency,
                rhythm: this.rhythmComplexity
            };
            recentSignals.push(signalData);
            setTimeout(()=>this.playSignal(), Math.random()*200);
        }
    }

    playSignal(){
        const freqs=this.signalMap[this.lastAction];
        const osc=audioCtx.createOscillator();
        const gain=audioCtx.createGain();
        osc.type='sine';
        osc.frequency.setValueAtTime(freqs[0]*(0.8+0.4*this.energy/50), audioCtx.currentTime);
        gain.gain.value = 0.1 + 0.05*this.rhythmComplexity;
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2 + 0.2*this.rhythmComplexity);
    }
}

// --- Simulation ---
let agents=[new Agent("ALEX"),new Agent("JOE"),new Agent("SAM"),new Agent("JESSE"), new Agent("BLAKE")];
let running=false, stepCount=0, intervalId=null;

function flattenAgents(agentList){
    let allAgents=[];
    agentList.forEach(a=>{ allAgents.push(a); if(a.children.length>0) allAgents=allAgents.concat(flattenAgents(a.children)); });
    return allAgents;
}

function simulateStep(){
    // NEW: Clear signals from the previous step so agents can hear new ones
    recentSignals = []; 
    
    const allAgents=flattenAgents(agents);
    const aliveAgents=allAgents.filter(a=>a.alive);
    
    aliveAgents.forEach(agent=>agent.act(allAgents));

    if(stepCount%5===0){
        environment.food=Math.min(environment.food+100,1000);
        environment.energy=Math.min(environment.energy+60,1000);
        environment.metal=Math.min(environment.metal+40,1000);
        environment.air=Math.min(environment.air+40, 1000)
        environment.trees=Math.min(environment.trees+100, 1000)
        environment.water=Math.min(environment.water+100, 1000)
        environment.fire=Math.min(environment.fire+40, 1000)
    }

    displayResources();
    displayLineage(agents);
    stepCount++;
}

// --- Resource bars ---
function displayResources(){
    const container=document.getElementById("resources");
    container.innerHTML='';
    for(const r in environment){
        const bar=document.createElement('div'); bar.className='resource-bar';
        const fill=document.createElement('div'); fill.className='resource-fill';
        fill.style.width=Math.min(environment[r],1000)/10+'%';
        bar.textContent=`${r}: ${Math.floor(environment[r])}`;
        bar.appendChild(fill);
        container.appendChild(bar);
    }
}

// --- Lineage display ---
const colors=["#FFFFFF","#66CCFF","#99FF66","#FFCC66","#FF6666"];
function displayLineage(agentList, container=document.getElementById("simulation"), depth=0){
    container.innerHTML='';
    function recurse(agent, depth){
        const div=document.createElement('div'); div.className='agent';
        const color=colors[Math.min(agent.generation,colors.length-1)];
        div.style.color=color;
        div.style.marginLeft=(depth*20)+'px';
        div.textContent=`${agent.name} (Gen ${agent.generation}): ${agent.alive?"ALIVE":"DEAD"} | F:${agent.food} E:${agent.energy} | Last:${agent.lastAction} | R:${agent.lifetimeReward.toFixed(1)}`;
        container.appendChild(div);
        agent.children.forEach(child=>recurse(child, depth+1));
    }
    agentList.forEach(a=>recurse(a, depth));
}

// --- Controls ---
document.getElementById("startBtn").onclick=()=>{ 
    if(!running){ 
        running=true; 
        intervalId=setInterval(simulateStep,100); 
    } 
};
document.getElementById("stopBtn").onclick=()=>{ running=false; clearInterval(intervalId); };
</script>
</body>
</html>
