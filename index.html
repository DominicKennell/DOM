<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DOM Simulation</title>
<style>
body {
    background: #1e1e1e;
    color: #fff;
    font-family: monospace;
    padding: 10px;
}
#controls { margin-bottom: 10px; }
button { padding: 5px 10px; margin-right: 5px; }
#resources {
    border: 1px solid #444;
    padding: 5px;
    margin-bottom: 10px;
}
#simulation {
    border: 1px solid #444;
    padding: 10px;
    max-height: 70vh;
    overflow-y: scroll;
}
.agent {
    margin-bottom: 2px;
}
</style>
</head>
<body>
<h1>SIMULATION DOM</h1>
<div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
</div>
<div id="resources"></div>
<div id="simulation"></div>

<script>
// --- Neural Network ---
class NeuralNetwork {
    constructor(inputSize=12, hiddenSize=16, outputSize=5, lr=0.01){
        this.inputSize=inputSize; this.hiddenSize=hiddenSize; this.outputSize=outputSize; this.lr=lr;
        this.W1=Array.from({length:hiddenSize}, ()=>Array.from({length:inputSize}, ()=>Math.random()*0.2-0.1));
        this.b1=Array(hiddenSize).fill(0);
        this.W2=Array.from({length:outputSize}, ()=>Array.from({length:hiddenSize}, ()=>Math.random()*0.2-0.1));
        this.b2=Array(outputSize).fill(0);
    }
    tanh(x){ return Math.tanh(x); }
    dtanh(y){ return 1-y*y; }
    softmax(arr){ const max=Math.max(...arr); const exps=arr.map(v=>Math.exp(v-max)); const sum=exps.reduce((a,b)=>a+b,0); return exps.map(v=>v/sum); }
    forward(x){
        this.x=x.slice();
        this.z1=this.W1.map((row,i)=>row.reduce((sum,v,j)=>sum+v*x[j],0)+this.b1[i]);
        this.a1=this.z1.map(v=>this.tanh(v));
        this.z2=this.W2.map((row,i)=>row.reduce((sum,v,j)=>sum+v*this.a1[j],0)+this.b2[i]);
        this.a2=this.softmax(this.z2);
        return this.a2;
    }
    train(actionIdx,reward){
        const dZ2=this.a2.slice(); dZ2[actionIdx]-=1; for(let i=0;i<dZ2.length;i++) dZ2[i]*=reward;
        const dW2=this.W2.map((row,i)=>row.map((v,j)=>dZ2[i]*this.a1[j])); const db2=dZ2.slice();
        const da1=Array(this.hiddenSize).fill(0);
        for(let i=0;i<this.hiddenSize;i++) for(let j=0;j<this.outputSize;j++) da1[i]+=this.W2[j][i]*dZ2[j];
        const dz1=da1.map((v,i)=>v*(1-this.a1[i]**2));
        const dW1=this.W1.map((row,i)=>row.map((v,j)=>dz1[i]*this.x[j])); const db1=dz1.slice();
        for(let i=0;i<this.W2.length;i++){ for(let j=0;j<this.W2[0].length;j++) this.W2[i][j]-=this.lr*dW2[i][j]; this.b2[i]-=this.lr*db2[i]; }
        for(let i=0;i<this.W1.length;i++){ for(let j=0;j<this.W1[0].length;j++) this.W1[i][j]-=this.lr*dW1[i][j]; this.b1[i]-=this.lr*db1[i]; }
    }
}

// --- Environment with extra resources ---
const environment = {
    food: 500,
    energy: 500,
    metal: 300,
    water: 400,
    fire: 200,
    air: 300,
    trees: 350
};

// --- Agent ---
class Agent{
    constructor(name,parent=null, generation=0){
        this.name=name; this.food=20; this.energy=20; this.metal=10; this.alive=true;
        this.strength=Math.floor(Math.random()*10)+1; this.cooperation=Math.random();
        this.lifetimeReward=0; this.children=[]; this.lastAction="None"; this.memory=[]; this.MAX_MEMORY=5; this.trust={};
        this.generation=generation;

        this.melodyTendency=parent ? Math.min(Math.max(parent.melodyTendency+(Math.random()-0.5)*0.2,0),1) : Math.random();
        this.rhythmComplexity=parent ? Math.min(Math.max(parent.rhythmComplexity+(Math.random()-0.5)*0.2,0),1) : Math.random();
        this.harmonyPreference=parent ? Math.min(Math.max(parent.harmonyPreference+(Math.random()-0.5)*0.2,0),1) : Math.random();

        if(parent){
            this.signalMap={};
            for(let action in parent.signalMap){
                this.signalMap[action]=parent.signalMap[action].map(f=>f+(Math.random()-0.5)*4);
            }
        } else {
            this.signalMap={gather:[400,500],trade:[500,600],fight:[700,800],social:[300,400],reproduce:[600,700]};
        }

        this.nn=new NeuralNetwork();
    }

    getState(){
        const avgReward=this.memory.length>0 ? this.memory.reduce((a,b)=>a+b[2],0)/this.memory.length :0;
        const avgTrust=Object.keys(this.trust).length>0 ? Object.values(this.trust).reduce((a,b)=>a+b,0)/Object.keys(this.trust).length :0;
        return [
            this.food/50,this.energy/50,this.metal/30,
            this.strength/10,this.cooperation,
            this.melodyTendency,this.rhythmComplexity,this.harmonyPreference,
            avgReward,avgTrust,this.memory.length/this.MAX_MEMORY,Math.random()
        ];
    }

    chooseAction(){
        const state=this.getState();
        const probs=this.nn.forward(state);
        let sum=0; const r=Math.random();
        for(let i=0;i<probs.length;i++){ sum+=probs[i]; if(r<sum){ this.lastActionIdx=i; break; } }
        const actions=["gather","trade","fight","social","reproduce"];
        this.lastAction=actions[this.lastActionIdx]||"gather";
        return this.lastAction;
    }

    act(agents){
        if(!this.alive) return;
        this.chooseAction(); let reward=0;
        agents.forEach(a=>{this.trust[a.name]=this.trust[a.name]||0.5; a.trust[this.name]=a.trust[this.name]||0.5; });

        switch(this.lastAction){
            case "gather":
                const resKeys=Object.keys(environment);
                const res=resKeys[Math.floor(Math.random()*resKeys.length)];
                const gathered=Math.min(environment[res],Math.floor(Math.random()*5)+1);
                environment[res]-=gathered;
                if(res==="food") this.food+=gathered;
                else if(res==="energy") this.energy+=gathered;
                else if(res==="metal") this.metal+=gathered;
                reward+=gathered/5;
                break;
            case "trade":
                const partners=agents.filter(a=>a!==this && a.alive && this.trust[a.name]>0.3);
                if(partners.length>0){
                    const partner=partners[Math.floor(Math.random()*partners.length)];
                    const tradeAmount=Math.min(this.metal,Math.floor(Math.random()*3)+1);
                    if(tradeAmount>0){ this.metal-=tradeAmount; partner.food+=tradeAmount; reward+=tradeAmount/3; }
                }
                break;
            case "fight":
                const targets=agents.filter(a=>a!==this && a.alive);
                if(targets.length>0){
                    const target=targets[Math.floor(Math.random()*targets.length)];
                    if(this.strength>target.strength){
                        const stolen=Math.min(target.food,Math.floor(Math.random()*3)+1);
                        target.food-=stolen; this.food+=stolen; reward+=stolen/3; this.trust[target.name]-=0.1;
                    } else { reward-=0.2; this.trust[target.name]+=0.05; }
                }
                break;
            case "social":
                this.food-=1; reward-=0.1; agents.forEach(a=>{ if(a!==this) this.trust[a.name]+=0.01; });
                break;
            case "reproduce":
                if(this.food>10 && this.energy>10){
                    this.food-=10; this.energy-=10;
                    const child=new Agent(this.name+"_child",this,this.generation+1);
                    this.children.push(child);
                    agents.push(child);
                    reward+=2.0;
                }
                break;
        }

        reward+=0.1; this.food-=1; this.energy-=1;
        if(this.food<=0 || this.energy<=0){ this.alive=false; reward-=5.0; }

        this.lifetimeReward+=reward;
        if(typeof this.lastActionIdx!=="undefined") this.nn.train(this.lastActionIdx,reward);
        if(this.alive) this.playSignal();
    }

    playSignal(){
        const freqs=this.signalMap[this.lastAction];
        const ctx=new (window.AudioContext||window.webkitAudioContext)();
        const osc=ctx.createOscillator();
        osc.type='sine'; osc.frequency.setValueAtTime(freqs[0],ctx.currentTime);
        osc.connect(ctx.destination);
        osc.start(); osc.stop(ctx.currentTime+0.2+0.2*this.rhythmComplexity);
    }
}

// --- Simulation ---
let agents=[new Agent("ALEX"),new Agent("JOE"),new Agent("SAM"),new Agent("JESSE")];
let running=false, stepCount=0, intervalId=null;

function flattenAgents(agentList){
    let allAgents=[];
    agentList.forEach(a=>{ allAgents.push(a); if(a.children.length>0) allAgents=allAgents.concat(flattenAgents(a.children)); });
    return allAgents;
}

function updateResources(){
    const container=document.getElementById("resources");
    container.innerHTML = `<strong>Resources:</strong> ` +
        Object.keys(environment).map(r=>`${r}: ${environment[r]}`).join(' | ');
}

function simulateStep(){
    try {
        const allAgents=flattenAgents(agents);
        const aliveAgents=allAgents.filter(a=>a.alive);
        aliveAgents.forEach(agent=>agent.act(allAgents));

        if(stepCount % 5===0){
            environment.food = Math.min(environment.food + 50, 1000);
            environment.energy = Math.min(environment.energy + 30, 1000);
            environment.metal = Math.min(environment.metal + 20, 1000);
            environment.air = Math.min(environment.air + 20, 1000);
            environment.trees = Math.min(environment.trees + 50, 1000);
            environment.water = Math.min(environment.water + 50, 1000);
            environment.fire = Math.min(environment.fire + 20, 1000);
        }

        displayLineage(agents);
        updateResources();
        stepCount++;
    } catch(e){ console.error("Simulation step error:", e); }
}

// --- Lineage tree display ---
const colors=["#FFFFFF","#66CCFF","#99FF66","#FFCC66","#FF6666"];
function displayLineage(agentList, container=document.getElementById("simulation"), depth=0){
    container.innerHTML='';
    function recurse(agent, depth){
        const div=document.createElement('div'); div.className='agent';
        const color=colors[Math.min(agent.generation, colors.length-1)];
        div.style.color=color; div.style.marginLeft=(depth*20)+'px';
        div.textContent=`${agent.name} (Gen ${agent.generation}): ${agent.alive?"ALIVE":"DEAD"} | F:${agent.food} E:${agent.energy} | Last:${agent.lastAction} | R:${agent.lifetimeReward.toFixed(1)}`;
        container.appendChild(div);
        agent.children.forEach(child=>recurse(child, depth+1));
    }
    agentList.forEach(agent=>recurse(agent, depth));
}

// --- Controls ---
document.getElementById("startBtn").onclick=()=>{ if(!running){ running=true; intervalId=setInterval(simulateStep,500); } };
document.getElementById("stopBtn").onclick=()=>{ running=false; clearInterval(intervalId); };

</script>
</body>
</html>
